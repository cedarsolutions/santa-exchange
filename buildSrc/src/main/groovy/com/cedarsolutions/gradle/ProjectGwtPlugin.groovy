// vim: set ft=groovy ts=4 sw=4:
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
// *
// *              C E D A R
// *          S O L U T I O N S       "Software done right."
// *           S O F T W A R E
// *
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
// *
// * Copyright (c) 2013 Kenneth J. Pronovici.
// * All rights reserved.
// *
// * This program is free software; you can redistribute it and/or
// * modify it under the terms of the Apache License, Version 2.0.
// * See LICENSE for more information about the licensing terms.
// *
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
// *
// * Author   : Kenneth J. Pronovici <pronovic@ieee.org>
// * Language : Gradle (>= 1.7)
// * Project  : Project Gradle Build Functionality
// *
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
package com.cedarsolutions.gradle

import org.gradle.api.Project
import org.gradle.api.Plugin

import org.gradle.api.plugins.JavaPlugin
import org.gradle.api.plugins.WarPlugin

/**
 * The projectGwt plugin.
 * @author Kenneth J. Pronovici, Cedar Solutions Inc.
 */
class ProjectGwtPlugin implements Plugin<Project> {

    /** Apply the plugin. */
    void apply(Project project) {
        project.plugins.apply(JavaPlugin)
        project.plugins.apply(WarPlugin)

        project.extensions.create("projectGwt", ProjectGwtPluginExtension, project)
        project.convention.plugins.projectGwt = new ProjectGwtPluginConvention(project)

        applyProjectGwt(project)
        applyProjectTestSuites(project)
    }

    /** Apply projectGwt. */
    void applyProjectGwt(Project project) {

        // We need to download the SDK before the classpath can be generated properly.
        project.tasks.compileJava.dependsOn(project.tasks.gaeDownloadSdk) 

        project.war {
            // The gradle build should not get any of the files generated by Eclipse
            excludes += [ "*.JUnit/**",
                          "*.JUnit",
                          "WEB-INF/deploy/**/*",
                          "WEB-INF/deploy",
                          "WEB-INF/classes/**/*",
                          "WEB-INF/classes",
                          "WEB-INF/lib/**/*",
                          "WEB-INF/lib",
                          "WEB-INF/appengine-generated/**/*",
                          "WEB-INF/appengine-generated", ]
        }

        // Compile GWT into the exploded war directory
        project.task("buildApplication", dependsOn: project.tasks.gaeExplodeWar) << {
            project.projectGwt.validateGwtConfig()

            def warDir = project.gaeExplodeWar.explodedWarDirectory.getPath()
            def moduleDir = project.file(warDir + "/" + project.projectGwt.getAppModuleName()).canonicalPath
            def classesDir = project.file(warDir + "/WEB-INF/classes").canonicalPath
            def libDir = project.file(warDir + "/WEB-INF/lib").canonicalPath
            def compilerClass = "com.google.gwt.dev.Compiler"

            project.file(moduleDir).deleteDir()  // It's proved difficult to exclude this via project.war.excludes

            project.ant.java(classname : compilerClass, fork : "true", failonerror : "true") {
                jvmarg(value: "-Xmx" + project.projectGwt.getGwtCompilerMemory())
                arg(value : "-war")
                arg(value : warDir)
                arg(value : project.projectGwt.getAppEntryPoint())
                classpath() {
                    pathelement(path: project.configurations.providedRuntime.asPath)
                    fileset(dir: libDir, includes : "*.jar")
                    pathelement(location: classesDir)
                    project.sourceSets.main.java.srcDirs.each { dir ->
                        pathelement(location: dir)
                    }
                }
            }
        } 

        // Start the development mode server
        project.task("startDevmode") << {
            project.convention.plugins.projectGwt.bootDevmode()
        }

        // Stop the development mode server
        project.task("stopDevmode") << {
            project.convention.plugins.projectGwt.killDevmode()
        }

        // Reboot the development mode server
        project.task("rebootDevmode") << {
            project.convention.plugins.projectGwt.rebootDevmode()
        }

    }

    /** Apply projectTestSuites. */
    void applyProjectTestSuites(Project project) {

        // Run unit tests, assumed to be found in a class suites/UnitTestSuite.
        // The caller that applies this plugin still has responsibility for making sure the suite gets compiled.
        project.task("unittest", type: org.gradle.api.tasks.testing.Test) {
            workingDir = project.projectDir
            scanForTestClasses = false
            enableAssertions = false
            outputs.upToDateWhen { false }
            include "suites/UnitTestSuite.class"
        }

        // Run GWT client tests, assumed to be found in a class suites/ClientTestSuite.
        // The caller that applies this plugin still has responsibility for making sure the suite gets compiled.
        project.task("clienttest", type: org.gradle.api.tasks.testing.Test) {
            workingDir = project.projectDir
            scanForTestClasses = false
            scanForTestClasses = false
            enableAssertions = false
            outputs.upToDateWhen { false }

            systemProperty "gwt.args", "-out www-test -logLevel ERROR"
            systemProperty "java.awt.headless", "true"   // required on Linux to avoid deferred binding errors

            include "suites/ClientTestSuite.class"

            beforeSuite { descriptor ->
                // Ugh, this gets called several different times for different internal Gradle "suites"
                if (descriptor.className == "suites.ClientTestSuite") {
                    def wwwTest = project.file(workingDir.canonicalPath + "/www-test")
                    def gwtCache = project.file(workingDir.canonicalPath + "/gwt-unitCache")
                    wwwTest.deleteDir()
                    gwtCache.deleteDir()
                }
            }

            afterSuite { descriptor ->
                // Ugh, this gets called several different times for different internal Gradle "suites"
                if (descriptor.className == "suites.ClientTestSuite") {
                    def wwwTest = project.file(workingDir.canonicalPath + "/www-test")
                    def gwtCache = project.file(workingDir.canonicalPath + "/gwt-unitCache")
                    wwwTest.deleteDir()
                    gwtCache.deleteDir()
                }
            }
        }

        // Effectively disable the standard test runner by making it look for a bogus class.
        project.tasks.test.include("**/bogus.class")

        // Redefine the test runner in terms of the unit and client test suites.
        project.tasks.test.dependsOn(project.tasks.clienttest, project.tasks.unittest)
        project.tasks.clienttest.mustRunAfter project.tasks.unittest

        // Run the Cucumber tests, assuming the devmode server is already up
        // Note that you have to manually build the application and boot devmode for this to work
        project.task("runCucumber") << {
            project.convention.plugins.projectGwt.execCucumber(null, null).assertNormalExitValue()
        }

        // Run the Cucumber tests, restricting by name containing a substring, assuming the devmode server is already up
        // Note that you have to manually build the application and boot devmode for this to work
        project.task("runCucumberByName") << {
            def name = null
            project.convention.plugins.cedarBuild.getInput("Configure Cucumber", "Test Name", false, { input -> name = input})
            project.convention.plugins.projectGwt.execCucumber(name, null).assertNormalExitValue()
        }

        // Run the Cucumber tests for a specific feature file, assuming the devmode server is already up
        // Note that you have to manually build the application and boot devmode for this to work
        project.task("runCucumberByFeature") << {
            def feature = null
            project.convention.plugins.cedarBuild.getInput("Configure Cucumber", "Feature Path", false, { input -> feature = input})
            project.convention.plugins.projectGwt.execCucumber(null, feature).assertNormalExitValue()
        }

        // Run the Cucumber tests, including a reboot of the server
        // Note that you have to manually build the application for this to work
        project.task("runCucumberWithReboot") << {
            project.convention.plugins.projectGwt.rebootDevmode()
            project.convention.plugins.projectGwt.waitForDevmode()
            project.convention.plugins.projectGwt.execCucumber(null, null).assertNormalExitValue()
        }

        // Run the acceptance tests, including a build of the application
        project.task("acceptancetest", dependsOn: project.tasks.buildApplication) << {
            project.convention.plugins.projectGwt.killDevmode()
            project.convention.plugins.projectGwt.bootDevmode()
            project.convention.plugins.projectGwt.waitForDevmode()
            def result = project.convention.plugins.projectGwt.execCucumber(null, null)
            project.convention.plugins.projectGwt.killDevmode()
            result.assertNormalExitValue()
        }

        // Define the order of tests if there are multiple called at the same time
        project.tasks.clienttest.mustRunAfter project.tasks.unittest
        project.tasks.acceptancetest.mustRunAfter project.tasks.clienttest

    }

}

