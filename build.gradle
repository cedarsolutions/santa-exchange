// vim: set ft=groovy ts=3:
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
// *
// *              C E D A R
// *          S O L U T I O N S       "Software done right."
// *           S O F T W A R E
// *
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
// *
// * Copyright (c) 2013 Kenneth J. Pronovici.
// * All rights reserved.
// *
// * This program is free software; you can redistribute it and/or
// * modify it under the terms of the Apache License, Version 2.0.
// * See LICENSE for more information about the licensing terms.
// *
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
// *
// * Author   : Kenneth J. Pronovici <pronovic@ieee.org>
// * Language : Gradle (>= 1.7)
// * Project  : Secret Santa Exchange
// *
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
// See: http://stackoverflow.com/questions/1163173/why-use-gradle-instead-of-ant-or-maven

// ***************
// * Gradle setup
// ***************

// Sources for the build script itself
buildscript {
   repositories {
      mavenLocal()   // Local Maven repository
      mavenCentral() // Maven Central repository
      maven { url "http://maven.cedar-common.googlecode.com/hg/maven/" }   // Cedar Common code
   }

   dependencies {
      classpath "com.googlecode.cedar-common:cedar-build:0.8.5"
      classpath "org.gradle.api.plugins:gradle-gae-plugin:0.9"
   }
} 

// Plugins
apply plugin: "base"
apply plugin: "eclipse"
apply plugin: "java"
apply plugin: "gae"  // I'm using this in only a limited way (for builds)
apply plugin: "cedarBuild"
apply plugin: "cedarCopyright"
apply plugin: "cedarJavadoc"
apply plugin: "cedarTestSuite"

// Load properties from standard configuration files (build.properties and local.properties)
cedarProperties.loadStandardProperties()

// Load properties from the GWT application configuration file
def gwtConfig = file(config_mercurialLabelResources).canonicalPath
cedarProperties.loadGwtProperties(gwtConfig, [ "system_applicationName", "system_versionNumber", "system_releaseDate", ])


// ************************
// * Project configuration
// ************************

compileJava.options.fork(memoryMaximumSize: config_javaCompilerMemory)

sourceCompatibility = JavaVersion.VERSION_1_6
targetCompatibility = JavaVersion.VERSION_1_6

tasks.compileJava.dependsOn(gaeDownloadSdk)  // We need to download the SDK before the classpath can be generated properly.

cedarLabel {
   enabled = config_mercurialLabelEnabled
   projectName = system_applicationName
   projectVersion = "${system_versionNumber} (${system_releaseDate})"
   repositories = [ projectDir, ]
   mercurialPath = config_mercurialPath
}

cedarCopyright {
   licensePattern = '^.*LICENSE$'
   sourcePatterns = [ '^.*\\.java$', '^.*\\.rb$', '^.*\\.feature$', '^.*\\.gradle$', '^.*build.xml$', ]
   repositories = [ projectDir, ]
   mercurialPath = config_mercurialPath
}

cedarJavadoc {
   title = "${system_applicationName} ${system_versionNumber}"
   output = "${project.docsDir}/javadoc"
   classpath = { project.configurations.runtime }
   srcDirs = { sourceSets.main.java.srcDirs }
   subpackages = [ "com", ]
}

gae {
   downloadSdk = true
   webAppDirName = "war"
}

war {
   // The gradle build should not get any of the files generated by Eclipse
   excludes += [ "${config_appModuleName}/**/*", 
                 "WEB-INF/classes/**/*", 
                 "WEB-INF/deploy/**/*", 
                 "WEB-INF/lib/**/*", 
                 "WEB-INF/appengine-generated/**/*",
                 "${config_appModuleName}", 
                 "WEB-INF/classes", 
                 "WEB-INF/deploy", 
                 "WEB-INF/lib", 
                 "WEB-INF/appengine-generated", ]
}

repositories {
   mavenLocal()   // Local Maven repository
   mavenCentral() // Maven Central repository
   maven { url "http://maven.objectify-appengine.googlecode.com/git/" }      // Objectify 3.x
   maven { url "http://mvp4g.googlecode.com/svn/maven2/snapshots/" }         // Mvp4g snapshots
   maven { url "http://repository.springsource.com/maven/bundles/external" } // Spring Source bundles
   maven { url "http://maven.cedar-common.googlecode.com/hg/maven/" }        // Cedar Common code
}

sourceSets {
   main {
      java { srcDirs = [ "src" ] }
      resources { srcDirs = [ "src", "resources", ] }
   }

   test {
      java { srcDirs = [ "test", "gradle/src/suites", ] }
      resources { srcDirs = [ "test", "gradle/src/suites", "gradle/resources", ] }
      runtimeClasspath += files(sourceSets.main.java.srcDirs)
      runtimeClasspath += files(sourceSets.main.resources.srcDirs)
      runtimeClasspath += files(sourceSets.test.java.srcDirs)
   }

   devmode {
   }
}

dependencies {
   gaeSdk "com.google.appengine:appengine-java-sdk:${config_appEngineVersion}"

   compile "com.google.gwt:gwt-servlet:${config_gwtVersion}"
   compile fileTree(dir: getAppEngineSdkDir(), includes: [ "lib/user/**/*.jar", ])
   compile "com.googlecode.cedar-common:cedar-common-util:${config_cedarCommonVersion}"
   compile "com.googlecode.cedar-common:cedar-common-gae:${config_cedarCommonVersion}"
   compile("com.googlecode.cedar-common:cedar-common-gwt:${config_cedarCommonVersion}") {
      exclude module: "com.google.gwt" // proper version is provided runtime, below
   }

   testCompile "com.googlecode.cedar-common:cpsuite:1.2.6" 
   testCompile "com.googlecode.cedar-common:cedar-common-testutil:${config_cedarCommonVersion}"
   testCompile "com.googlecode.cedar-common:cedar-common-gwttestutil:${config_cedarCommonVersion}"
   testCompile "com.googlecode.cedar-common:cedar-common-gaetestutil:${config_cedarCommonVersion}"

   runtime("org.apache.xalan:com.springsource.org.apache.xalan:2.7.1") { transitive = false }
   runtime("org.apache.xerces:com.springsource.org.apache.xerces:2.9.1") { transitive = false }
   runtime "org.aspectj:aspectjrt:1.6.12"

   providedRuntime "com.google.gwt:gwt-dev:${config_gwtVersion}"
   providedRuntime "com.google.gwt:gwt-user:${config_gwtVersion}"

   devmodeRuntime fileTree(dir: getAppEngineSdkDir(), includes: [ "lib/appengine-tools-api.jar", ])
}

configurations {
   // We get the AppEngine jars directly from the SDK zip, to ease our burden with Eclipse
   all*.exclude group: "com.google.appengine", module: "appengine-api-1.0-sdk"

   // These transitive dependencies are not required for the application to work properly
   all*.exclude group: "antlr", module: "antlr"
   all*.exclude group: "asm", module: "asm"
   all*.exclude group: "commons-chain", module: "commons-chain"
   all*.exclude group: "commons-codec", module: "commons-codec"
   all*.exclude group: "commons-codec", module: "commons-codec"
   all*.exclude group: "commons-digester", module: "commons-digester"
   all*.exclude group: "commons-validator", module: "commons-validator"
   all*.exclude group: "dom4j", module: "dom4j"
   all*.exclude group: "javax.activation", module: "activation"
   all*.exclude group: "javax.servlet", module: "servlet-api"
   all*.exclude group: "javax.transaction", module: "transaction-api"
   all*.exclude group: "org.apache.struts"
   all*.exclude group: "org.json", module: "json"
   all*.exclude group: "org.sonatype.sisu.inject", module: "cglib"
   all*.exclude group: "org.springframework", module: "spring-support"
   all*.exclude group: "sslext", module: "sslext"
}


// ****************
// * Javadoc tasks
// ****************

// Generate Javadoc for into the Mercurial repository.
task generateJavadoc(dependsOn: jdoc) << {
   copyJavadocToMercurial(config_mercurialJavadocProject, project, { name -> name })
}


// ************
// * GWT tasks
// ************

// Compile GWT into the exploded war directory
task buildApplication(dependsOn: gaeExplodeWar) << {
   def warDir = gaeExplodeWar.explodedWarDirectory.getPath()
   def classesDir = file(warDir + "/WEB-INF/classes").canonicalPath
   def libDir = file(warDir + "/WEB-INF/lib").canonicalPath
   def compilerClass = "com.google.gwt.dev.Compiler"

   ant.java(classname : compilerClass, fork : "true", failonerror : "true") {
      jvmarg(value: "-Xmx${config_gwtCompilerMemory}")
      arg(value : "-war")
      arg(value : warDir)
      arg(value : config_appEntryPoint)
      classpath() {
          pathelement(path: configurations.providedRuntime.asPath)
          fileset(dir: libDir, includes : "*.jar")
          pathelement(location: classesDir)
          sourceSets.main.java.srcDirs.each { dir ->
            pathelement(location: dir)
         }
      }
   }
}


// *******************
// * App Engine tasks
// *******************

// Start the GAE development mode server
task startDevmode() << {
   bootDevmode()
}

// Stop the GAE development mode server
task stopDevmode() << {
   killDevmode()
}

// Get the location of the exploded App Engine SDK directory on disk
def getAppEngineSdkDir() {
   return file(gaeDownloadSdk.explodedSdkDirectory.getPath() + "/appengine-java-sdk-${config_appEngineVersion}").canonicalPath
}

// Get the location of the appengine agent jar
def getAppEngineAgentJar() {
   return file(getAppEngineSdkDir() + "/lib/agent/appengine-agent.jar").canonicalPath
}

// Boot the GAE development mode server
def bootDevmode() {
   def warDir = gaeExplodeWar.explodedWarDirectory.getPath()
   def cacheDir = file(warDir + "/WEB-INF/appengine-generated").canonicalPath
   def classesDir = file(warDir + "/WEB-INF/classes").canonicalPath
   def libDir = file(warDir + "/WEB-INF/lib").canonicalPath
   def agentJar = getAppEngineAgentJar()
   def serverClass = "com.google.gwt.dev.DevMode"
   def launcher = "com.google.appengine.tools.development.gwt.AppEngineLauncher"

   cleanupCacheDirs()

   ant.java(classname: serverClass, dir: warDir, fork: "true", spawn: "true") {
      jvmarg(value: "-Xmx${config_devmodeServerMemory}")
      jvmarg(value: "-javaagent:${agentJar}")
      arg(line: "-startupUrl")
      arg(value: "${config_appStartupUrl}")
      arg(line: "-war")
      arg(value: "${warDir}")
      arg(line: "-logLevel")
      arg(value: "INFO")
      arg(line: "-codeServerPort")
      arg(value: "${config_devmodeCodeserverPort}")
      arg(line: "-port")
      arg(value: "${config_devmodeServerPort}")
      arg(line: "-server")
      arg(line: launcher)
      arg(value: "${config_appEntryPoint}")
      classpath() {
          fileset(dir: libDir, includes : "*.jar")
          pathelement(location: classesDir)
          configurations.devmodeRuntime.each { jar -> pathelement(location: jar.canonicalPath) }
          configurations.providedRuntime.each { jar -> pathelement(location: jar.canonicalPath) }
          sourceSets.main.java.srcDirs.each { dir -> pathelement(location: dir) }
      }
   }
}

// Kill the GAE development mode server
def killDevmode() {
   // Unfortunately, this only works on Windows for now
   ant.exec(executable: "taskkill") {
      arg(value: "/fi")
      arg(value: '"Windowtitle eq GWT Development Mode"')
   }
}

// Clean up the test directories that are created in the workspace
def cleanupCacheDirs() {
   file("gwt-unitCache").deleteDir()
   file("www-test").deleteDir()
   file("build/gwtUnitCache").deleteDir()
   file(gaeExplodeWar.explodedWarDirectory.getPath() + "/WEB-INF/appengine-generated").deleteDir()
}


// *************
// * Test tasks
// *************

// Run the Cucumber tests, assuming the devmode server is already up
// Note that you have to manually build the application and boot devmode for this to work
task runCucumber() << {
   execCucumber().assertNormalExitValue()
}

// Run the Cucumber tests, including a reboot of the server
// Note that you have to manually build the application for this to work
task runCucumberWithReboot() << {
   killDevmode()   
   bootDevmode()
   waitForDevmode()
   execCucumber().assertNormalExitValue()
}

// Run the acceptance tests, including a build of the application
task acceptancetest(dependsOn: buildApplication) << {
   killDevmode()   
   bootDevmode()
   waitForDevmode()
   def result = execCucumber()
   killDevmode()   
   result.assertNormalExitValue()
}

// Clean up the test directories used by Eclipse
task cleanupEclipseTestDirs() << {
   cleanupCacheDirs()
}

// Clean up all of the Eclipse test directories whenever everything else is cleaned
tasks.clean.dependsOn(cleanupEclipseTestDirs)

// Wait for devmode to start, based on configuration
def waitForDevmode() {
   sleep Integer.parseInt(config_serverWait) * 1000;  // wait for dev mode to finish booting
}

// Exec the cucumber tests, returning an ExecResult so caller can handle failures
def execCucumber() {
   return project.exec {
      workingDir = "acceptance"
      ignoreExitValue = true
      executable = file("${config_rubyBinDir}/${config_rubyInterpreter}").canonicalPath
      args = [ file("${config_rubyBinDir}/${config_rubyCucumberProgram}").canonicalPath, ]
   }
}


// ************************
// * Eclipse configuration
// ************************
// The eclipse plugin is used to generate Eclipse project files

// Always re-generate everything, otherwise we get duplicate sections in files
tasks.eclipse.dependsOn(cleanEclipse)

// Clean up extended settings
task cleanEclipseExtendedSettings(type: Delete) << {

   // Delete the settings we copied in
   file(".settings/de.loskutov.anyedit.AnyEditTools.prefs").delete()
   file(".settings/org.eclipse.jdt.core.prefs").delete()
   file(".settings/org.eclipse.jdt.ui.prefs").delete()
   file(".externalToolBuilders/com.google.appengine.eclipse.core.enhancerbuilder.launch").delete()

   // Remove .settings and .externalToolBuilders only if they're empty
   ant.delete(includeemptydirs : "true", quiet : "true") {
      fileset(dir: ".settings", excludes : "**/*")
      fileset(dir: ".externalToolBuilders", excludes : "**/*")
   }

}

// Cleanup the runtime libraries
task cleanupRuntimeLibraries() << {
   ant.delete(includeemptydirs: "true", quiet: "true") {
      fileset(dir: "war/WEB-INF/lib", includes: "**/*")
   }
}

// Copy the runtime libraries to war/WEB-INF/lib to make the Eclipse web application launcher happy
task copyRuntimeLibraries << {
    copy {
        into "war/WEB-INF/lib"
        from configurations.runtime.files
    }
}

// Clean up runtime libraries whenever the rest of Eclipse gets cleaned up
tasks.cleanEclipse.dependsOn(cleanupRuntimeLibraries)

// Clean up custom settings whenever the rest of Eclipse gets cleaned up
tasks.cleanEclipseJdt.dependsOn(cleanEclipseExtendedSettings)

// We need to download the SDK before the classpath can be generated properly.
// We also want to copy the jars into the WEB-INF/lib directory at the same time.
tasks.eclipseClasspath.dependsOn(gaeDownloadSdk, copyRuntimeLibraries)

// Copy skeleton settings into the workspace
eclipseJdt << {
   mkdir ".settings"
   copy {
      from "gradle/eclipse/settings"
      into ".settings"
      include "*.prefs"
   }

   mkdir ".externalToolBuilders"
   copy {
      from "gradle/eclipse/externalToolBuilders"
      into ".externalToolBuilders"
      include "*"
   }
}

// Customize the Eclipse .project file
eclipse {
   project {
      natures "org.eclipse.jdt.core.javanature"
      natures "com.google.appengine.eclipse.core.gaeNature"
      natures "com.google.gwt.eclipse.core.gwtNature"
      natures "net.sf.eclipsecs.core.CheckstyleNature"
      natures "net.sourceforge.metrics.nature"

      buildCommand "org.eclipse.jdt.core.javabuilder"
      buildCommand "net.sf.eclipsecs.core.CheckstyleBuilder"
      // no "com.google.gdt.eclipse.core.webAppProjectValidator"
      // no ""com.google.gwt.eclipse.core.gwtProjectValidator"
      // no "com.google.appengine.eclipse.core.projectValidator"

      // See: http://stackoverflow.com/questions/6442619/launching-gradle-builds-from-eclipse
      def builder = "<project>/.externalToolBuilders/com.google.appengine.eclipse.core.enhancerbuilder.launch"
      buildCommand "org.eclipse.ui.externaltools.ExternalToolBuilder", LaunchConfigHandle: builder
      file {
         withXml {
            def projectNode = it.asNode()
            projectNode.iterator().each { subNode ->
               String subNodeText = "" + subNode
               if (subNodeText.startsWith("buildSpec")) {
                  subNode.iterator().each { buildCmd ->
                     String nameNode = buildCmd?.name
                     if (nameNode.contains("ExternalToolBuilder")) {
                        buildCmd.appendNode("triggers", "full,incremental,")
                     }
                  }
               }
            }
         }
      }
   }
}  

// Hide the various derived directories from Eclipse
project.eclipse.project.file.withXml { provider ->
   ignoreResourcesFromDirectories(provider, [ ".gradle",
                                              "build", 
                                              "gwt-unitCache", 
                                              "www-test", 
                                              "war/${config_appEntryPoint}.JUnit", 
                                              "war/${config_appModuleName}", 
                                              "war/WEB-INF/deploy", 
                                              "war/WEB-INF/lib", 
                                              "war/WEB-INF/appengine-generated", 
                                              "WEB-INF", 
                                              "extras", ])
}

// Customize the Eclipse .classpath file
eclipse.classpath.file {
   whenMerged { classpath ->

      // Change the default output directory to war/WEB-INF/classes instead of bin
      classpath.entries.findAll { entry -> entry.kind == "output" && entry.path == "bin" }.each { entry ->
         entry.path = "war/WEB-INF/classes"
      }

      // Test output should go to test-bin, so it can be separated for coverage purposes
      classpath.entries.findAll { entry -> entry.kind == "src" && entry.path == "test" }.each { entry ->
         entry.output = "test-bin"
      }

      // Replace the "gradle/src/suites source" folder with just "suites", and send classes to test-bin
      classpath.entries.findAll { entry -> entry.kind == "src" && entry.path == "gradle/src/suites" }.each { entry ->
         entry.path = "suites"
         entry.output = "test-bin"
      }

      // Add the devmode runtime dependencies to the Eclipse classpath
      // Note: the ".nondependency" attributes means that this shouldn't go into the war
      withXml { xml ->
         def node = xml.asNode()
         configurations.devmodeRuntime.each { devmode ->
            node.appendNode("classpathentry", [ kind : "lib", path : devmode.canonicalPath, exported : "true", ])
                .appendNode("attributes").appendNode("attribute",  [ name : "org.eclipse.jst.component.nondependency", value : "", ])
         }
      }

      // Exclude the provided dependencies (like GWT) from the war file so Eclipse is consistent with gradle build
      // Note: the ".nondependency" attributes means that this shouldn't go into the war
      withXml { xml ->
         def node = xml.asNode()
         configurations.providedRuntime.each { provided ->
            def path = provided.canonicalPath.replace("\\", "/")
            node."classpathentry".findAll { it.@kind == "lib" && it.@path == path }.each { entry ->
               entry.appendNode("attributes").appendNode("attribute",  [ name : "org.eclipse.jst.component.nondependency", value : "", ])
            }
         }
      } 

      // Reorder the source packages the way I want them to appear
      def order = [ "resources", "src", "test", "suites", ]
      def all = classpath.entries.findAll { entry -> entry.kind == "src" }
      classpath.entries.removeAll(all)
      order.eachWithIndex() { path, index -> 
         all.findAll { entry -> entry.kind == "src" && entry.path == path }.each { entry -> 
            classpath.entries.add(index, entry) 
         } 
      }

      // Put all of the "con" classpath entries (like the JRE container) at the bottom
      all = classpath.entries.findAll { entry -> entry.kind == "con" }
      classpath.entries.removeAll(all)
      withXml { xml ->
         def node = xml.asNode()
         all.findAll { entry ->
            node.appendNode("classpathentry", [ kind : "con", path : entry.path, exported : entry.exported, ])
         }
      }

   }
}

