// vim: set ft=groovy:
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
// *
// *              C E D A R
// *          S O L U T I O N S       "Software done right."
// *           S O F T W A R E
// *
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
// *
// * Copyright (c) 2011-2013 Kenneth J. Pronovici.
// * All rights reserved.
// *
// * This program is free software; you can redistribute it and/or
// * modify it under the terms of the Apache License, Version 2.0.
// * See LICENSE for more information about the licensing terms.
// *
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
// *
// * Author   : Kenneth J. Pronovici <pronovic@ieee.org>
// * Language : Gradle (>= 1.7)
// * Project  : Secret Santa Exchange
// *
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
// See: http://stackoverflow.com/questions/1163173/why-use-gradle-instead-of-ant-or-maven

// ***************
// * Gradle setup
// ***************

// Sources for the build script itself
buildscript {
   repositories { 
      mavenCentral() 
   }

   dependencies { 
      classpath "org.gradle.api.plugins:gradle-gae-plugin:0.9"
      classpath "com.admc:gradle-javaPropFile-plugin:0.6.0" 
   }
}

// Plugins
apply plugin: "base"
apply plugin: "eclipse"
apply plugin: "javaPropFile"
apply plugin: "java"
apply plugin: "gae"  // I'm using this in only a limited way (for builds)

// This loads configuration from app.properties and overrides with local.properties
// See: https://github.com/unsaved/gradle-javaPropFile-plugin/tree/master/doc#void-propfileloadertraditionalpropertiesinit
propFileLoader.traditionalPropertiesInit()


// ************************
// * Project configuration
// ************************

compileJava.options.fork(memoryMaximumSize: config_javaCompilerMemory)

sourceCompatibility = JavaVersion.VERSION_1_6
targetCompatibility = JavaVersion.VERSION_1_6

// We need to download the SDK before the classpath can be generated properly.
tasks.compileJava.dependsOn(gaeDownloadSdk)

gae {
   downloadSdk = true
   webAppDirName = "war"
}

war {
   // The gradle build should not get any of the files generated by Eclipse
   excludes += [ "santaexchange/**/*", 
                 "WEB-INF/classes/**/*", 
                 "WEB-INF/deploy/**/*", 
                 "WEB-INF/lib/**/*", 
                 "WEB-INF/appengine-generated/**/*",
                 "santaexchange", 
                 "WEB-INF/classes", 
                 "WEB-INF/deploy", 
                 "WEB-INF/lib", 
                 "WEB-INF/appengine-generated", ]
}

repositories {
   mavenLocal()   // Local Maven repository
   mavenCentral() // Maven Central repository
   maven { url "http://maven.objectify-appengine.googlecode.com/git/" }      // Objectify 3.x
   maven { url "http://mvp4g.googlecode.com/svn/maven2/snapshots/" }         // Mvp4g snapshots
   maven { url "http://repository.springsource.com/maven/bundles/external" } // Spring Source bundles
   maven { url "http://maven.cedar-common.googlecode.com/hg/maven/" }        // Cedar Common code
}

sourceSets {
   main {
      java { srcDirs = [ "src" ] }
      resources { srcDirs = [ "src", "resources", ] }
   }

   test {
      java { srcDirs = [ "test", "gradle/src/suites", ] }
      resources { srcDirs = [ "test", "gradle/src/suites", "gradle/resources", ] }
      runtimeClasspath += files(sourceSets.main.java.srcDirs)
      runtimeClasspath += files(sourceSets.main.resources.srcDirs)
      runtimeClasspath += files(sourceSets.test.java.srcDirs)
   }

   tools {
   }

   devmode {
   }
}

dependencies {
   gaeSdk "com.google.appengine:appengine-java-sdk:${config_appEngineVersion}"

   compile "com.google.gwt:gwt-servlet:${config_gwtVersion}"
   compile fileTree(dir: getAppEngineSdkDir(), includes: [ "lib/user/**/*.jar", ])
   compile "com.googlecode.cedar-common:cedar-common-util:2.1.+"
   compile "com.googlecode.cedar-common:cedar-common-gae:2.1.+"
   compile("com.googlecode.cedar-common:cedar-common-gwt:2.1.+") {
      exclude module: "com.google.gwt" // proper version is provided runtime, below
   }

   testCompile "com.googlecode.cedar-common:cpsuite:1.2.6" 
   testCompile "com.googlecode.cedar-common:cedar-common-testutil:2.1.+"
   testCompile "com.googlecode.cedar-common:cedar-common-gwttestutil:2.1.+"
   testCompile "com.googlecode.cedar-common:cedar-common-gaetestutil:2.1.+"

   runtime("org.apache.xalan:com.springsource.org.apache.xalan:2.7.1") { transitive = false }
   runtime("org.apache.xerces:com.springsource.org.apache.xerces:2.9.1") { transitive = false }
   runtime "org.aspectj:aspectjrt:1.6.12"

   providedRuntime "com.google.gwt:gwt-dev:${config_gwtVersion}"
   providedRuntime "com.google.gwt:gwt-user:${config_gwtVersion}"

   toolsRuntime "com.googlecode.cedar-common:cedar-common-tools:2.1.+"

   devmodeRuntime fileTree(dir: getAppEngineSdkDir(), includes: [ "lib/appengine-tools-api.jar", ])
}

configurations {
   // We get the AppEngine jars directly from the SDK zip, to ease our burden with Eclipse
   all*.exclude group: "com.google.appengine", module: "appengine-api-1.0-sdk"

   // These transitive dependencies are not required for the application to work properly
   all*.exclude group: "antlr", module: "antlr"
   all*.exclude group: "asm", module: "asm"
   all*.exclude group: "commons-chain", module: "commons-chain"
   all*.exclude group: "commons-codec", module: "commons-codec"
   all*.exclude group: "commons-codec", module: "commons-codec"
   all*.exclude group: "commons-digester", module: "commons-digester"
   all*.exclude group: "commons-validator", module: "commons-validator"
   all*.exclude group: "dom4j", module: "dom4j"
   all*.exclude group: "javax.activation", module: "activation"
   all*.exclude group: "javax.servlet", module: "servlet-api"
   all*.exclude group: "javax.transaction", module: "transaction-api"
   all*.exclude group: "org.apache.struts"
   all*.exclude group: "org.json", module: "json"
   all*.exclude group: "org.sonatype.sisu.inject", module: "cglib"
   all*.exclude group: "org.springframework", module: "spring-support"
   all*.exclude group: "sslext", module: "sslext"
}


// ************
// * GWT tasks
// ************

// Compile GWT into the exploded war directory
task buildApplication(dependsOn: gaeExplodeWar) << {
   def warDir = gaeExplodeWar.explodedWarDirectory.getPath()
   def classesDir = file(warDir + "/WEB-INF/classes").canonicalPath
   def libDir = file(warDir + "/WEB-INF/lib").canonicalPath
   def compilerClass = "com.google.gwt.dev.Compiler"

   ant.java(classname : compilerClass, fork : "true", failonerror : "true") {
      jvmarg(value: "-Xmx${config_gwtCompilerMemory}")
      arg(value : "-war")
      arg(value : warDir)
      arg(value : config_appEntryPoint)
      classpath() {
          pathelement(path: configurations.providedRuntime.asPath)
          fileset(dir: libDir, includes : "*.jar")
          pathelement(location: classesDir)
          sourceSets.main.java.srcDirs.each { dir ->
            pathelement(location: dir)
         }
      }
   }
}


// *******************
// * App Engine tasks
// *******************

// Start the GAE development mode server
task startDevmode() << {
   bootDevmode()
}

// Stop the GAE development mode server
task stopDevmode() << {
   killDevmode()
}

// Get the location of the exploded App Engine SDK directory on disk
def getAppEngineSdkDir() {
   return file(gaeDownloadSdk.explodedSdkDirectory.getPath() + "/appengine-java-sdk-${config_appEngineVersion}").canonicalPath
}

// Get the location of the appengine agent jar
def getAppEngineAgentJar() {
   return file(getAppEngineSdkDir() + "/lib/agent/appengine-agent.jar").canonicalPath
}

// Boot the GAE development mode server
def bootDevmode() {
   def warDir = gaeExplodeWar.explodedWarDirectory.getPath()
   def cacheDir = file(warDir + "/WEB-INF/appengine-generated").canonicalPath
   def classesDir = file(warDir + "/WEB-INF/classes").canonicalPath
   def libDir = file(warDir + "/WEB-INF/lib").canonicalPath
   def agentJar = getAppEngineAgentJar()
   def serverClass = "com.google.gwt.dev.DevMode"
   def launcher = "com.google.appengine.tools.development.gwt.AppEngineLauncher"

   cleanupCacheDirs()

   ant.java(classname: serverClass, dir: warDir, fork: "true", spawn: "true") {
      jvmarg(value: "-Xmx${config_devmodeServerMemory}")
      jvmarg(value: "-javaagent:${agentJar}")
      arg(line: "-startupUrl")
      arg(value: "${config_appStartupUrl}")
      arg(line: "-war")
      arg(value: "${warDir}")
      arg(line: "-logLevel")
      arg(value: "INFO")
      arg(line: "-codeServerPort")
      arg(value: "${config_devmodeCodeserverPort}")
      arg(line: "-port")
      arg(value: "${config_devmodeServerPort}")
      arg(line: "-server")
      arg(line: launcher)
      arg(value: "${config_appEntryPoint}")
      classpath() {
          fileset(dir: libDir, includes : "*.jar")
          pathelement(location: classesDir)
          configurations.devmodeRuntime.each { jar -> pathelement(location: jar.canonicalPath) }
          configurations.providedRuntime.each { jar -> pathelement(location: jar.canonicalPath) }
          sourceSets.main.java.srcDirs.each { dir -> pathelement(location: dir) }
      }
   }
}

// Kill the GAE development mode server
def killDevmode() {
   // Unfortunately, this only works on Windows for now
   ant.exec(executable: "taskkill") {
      arg(value: "/fi")
      arg(value: '"Windowtitle eq GWT Development Mode"')
   }
}

// Clean up the test directories that are created in the workspace
def cleanupCacheDirs() {
   file("gwt-unitCache").deleteDir()
   file("www-test").deleteDir()
   file("build/gwtUnitCache").deleteDir()
   file(gaeExplodeWar.explodedWarDirectory.getPath() + "/WEB-INF/appengine-generated").deleteDir()
}


// *************
// * Test tasks
// *************

// Unit tests are defined by the UnitTestSuite
task unittest(type: Test) {
   scanForTestClasses = false
   enableAssertions = false
   outputs.upToDateWhen { false }
   include "**/UnitTestSuite.class"
}

// Client tests are defined by the ClientTestSuite
task clienttest(type: Test) {
   scanForTestClasses = false
   enableAssertions = false
   outputs.upToDateWhen { false }
   systemProperty "gwt.args", "-out build/www-test -logLevel ERROR"
   include "**/ClientTestSuite.class"

   beforeSuite { descriptor ->
      file("build/www-test").deleteDir()
      file("build/gwt-unitCache").deleteDir()
   }

   afterSuite { descriptor ->
      file("build/www-test").deleteDir()
      file("build/gwt-unitCache").deleteDir()
   }
}

// Effectively disable the standard test runner
test {
   include "**/bogus.class"  // so nothing gets run
}

// Redefine the test runner in terms of the unit and client test suites
tasks.test.dependsOn(clienttest, unittest) 

// Run the Cucumber tests, assuming the devmode server is already up
// Note that you have to manually build the application and boot devmode for this to work
task runCucumber() << {
   execCucumber().assertNormalExitValue()
}

// Run the Cucumber tests, including a reboot of the server
// Note that you have to manually build the application for this to work
task runCucumberWithReboot() << {
   killDevmode()   
   bootDevmode()
   waitForDevmode()
   execCucumber().assertNormalExitValue()
}

// Run the acceptance tests, including a build of the application
task acceptancetest(dependsOn: buildApplication) << {
   killDevmode()   
   bootDevmode()
   waitForDevmode()
   def result = execCucumber()
   killDevmode()   
   result.assertNormalExitValue()
}

// Clean up the test directories used by Eclipse
task cleanupEclipseTestDirs() << {
   cleanupCacheDirs()
}

// Clean up all of the Eclipse test directories whenever everything else is cleaned
tasks.clean.dependsOn(cleanupEclipseTestDirs)

// Wait for devmode to start, based on configuration
def waitForDevmode() {
   sleep Integer.parseInt(config_serverWait) * 1000;  // wait for dev mode to finish booting
}

// Exec the cucumber tests, returning an ExecResult so caller can handle failures
def execCucumber() {
   return project.exec {
      workingDir = "acceptance"
      ignoreExitValue = true
      executable = file("${config_rubyBinDir}/${config_rubyInterpreter}").canonicalPath
      args = [ file("${config_rubyBinDir}/${config_rubyCucumberProgram}").canonicalPath, ]
   }
}


// ********************
// * Other build tasks
// ********************

// Label the current release using the configured config_mavenPublishVersion
task labelCurrentRelease(dependsOn: gaeExplodeWar) << {
   def warDir = gaeExplodeWar.explodedWarDirectory.getPath()
   def classesDir = file(warDir + "/WEB-INF/classes").canonicalPath
   def libDir = file(warDir + "/WEB-INF/lib").canonicalPath
   def label = '$${system_applicationName}_v$${system_versionNumber}_($${system_releaseDate})__$${special:ntimestamp}'
   def toolClass = "com.cedarsolutions.tools.label.LabelTool"

   ant.java(classname : toolClass, fork : "true", failonerror : "true") {
      arg(value: "--label")
      arg(value: label)
      arg(value: "--hg")
      arg(value: config_mercurialPath)
      arg(value: "--repo")
      arg(value: projectDir)
      arg(value: "--resource-class")
      arg(value: config_mercurialLabelResources)
      classpath() {
          pathelement(path: configurations.providedRuntime.asPath)
          pathelement(path: configurations.toolsRuntime.asPath)
          fileset(dir: libDir, includes : "*.jar")
          pathelement(location: classesDir)
          sourceSets.main.java.srcDirs.each { dir ->
            pathelement(location: dir)
         }
      }
   }
}

// Update all copyright statements based on Mercurial repository
task updateCopyrightStatements(dependsOn: gaeExplodeWar) << {
   def warDir = gaeExplodeWar.explodedWarDirectory.getPath()
   def classesDir = file(warDir + "/WEB-INF/classes").canonicalPath
   def libDir = file(warDir + "/WEB-INF/lib").canonicalPath
   def licensePattern = '^.*LICENSE$'
   def sourcePatterns = '"^.*\\.java$" "^.*\\.rb$" "^.*\\.feature$" "^.*build.xml$"'
   def toolClass = "com.cedarsolutions.tools.copyright.CopyrightTool"

   ant.java(classname : toolClass, fork : "true", failonerror : "true") {
      arg(value : config_mercurialPath)
      arg(value : projectDir)
      arg(value : licensePattern)
      arg(line  : sourcePatterns)
      classpath() {
          pathelement(path: configurations.providedRuntime.asPath)
          pathelement(path: configurations.toolsRuntime.asPath)
          fileset(dir: libDir, includes : "*.jar")
          pathelement(location: classesDir)
          sourceSets.main.java.srcDirs.each { dir ->
            pathelement(location: dir)
         }
      }
   }
} 


// ************************
// * Eclipse configuration
// ************************
// The eclipse plugin is used to generate Eclipse project files

// Always re-generate everything, otherwise we get duplicate sections in files
tasks.eclipse.dependsOn(cleanEclipse)

// Clean up extended settings
task cleanEclipseExtendedSettings(type: Delete) {

   // Delete the settings we copied in
   file(".settings/de.loskutov.anyedit.AnyEditTools.prefs").delete()
   file(".settings/org.eclipse.jdt.core.prefs").delete()
   file(".settings/org.eclipse.jdt.ui.prefs").delete()
   file(".externalToolBuilders/com.google.appengine.eclipse.core.enhancerbuilder.launch").delete()

   // Remove .settings and .externalToolBuilders only if they're empty
   ant.delete(includeemptydirs : "true", quiet : "true") {
      fileset(dir: ".settings", excludes : "**/*")
      fileset(dir: ".externalToolBuilders", excludes : "**/*")
   }

}

// Copy the runtime libraries to war/WEB-INF/lib to make the Eclipse web application launcher happy
task copyRuntimeLibraries << {
    copy {
        into "war/WEB-INF/lib"
        from configurations.runtime.files
    }
}

// Clean up custom settings whenever the rest of Eclipse gets cleaned up
tasks.cleanEclipseJdt.dependsOn(cleanEclipseExtendedSettings)

// We need to download the SDK before the classpath can be generated properly.
// We also want to copy the jars into the WEB-INF/lib directory at the same time.
tasks.eclipseClasspath.dependsOn(gaeDownloadSdk, copyRuntimeLibraries)

// Copy skeleton settings into the workspace
eclipseJdt << {
   mkdir ".settings"
   copy {
      from "gradle/eclipse/settings"
      into ".settings"
      include "*.prefs"
   }

   mkdir ".externalToolBuilders"
   copy {
      from "gradle/eclipse/externalToolBuilders"
      into ".externalToolBuilders"
      include "*"
   }
}

// Customize the Eclipse .project file
eclipse {
   project {
      natures "org.eclipse.jdt.core.javanature"
      natures "com.google.appengine.eclipse.core.gaeNature"
      natures "com.google.gwt.eclipse.core.gwtNature"
      natures "net.sf.eclipsecs.core.CheckstyleNature"
      natures "net.sourceforge.metrics.nature"

      buildCommand "org.eclipse.jdt.core.javabuilder"
      buildCommand "net.sf.eclipsecs.core.CheckstyleBuilder"
      // no "com.google.gdt.eclipse.core.webAppProjectValidator"
      // no ""com.google.gwt.eclipse.core.gwtProjectValidator"
      // no "com.google.appengine.eclipse.core.projectValidator"

      // See: http://stackoverflow.com/questions/6442619/launching-gradle-builds-from-eclipse
      def builder = "<project>/.externalToolBuilders/com.google.appengine.eclipse.core.enhancerbuilder.launch"
      buildCommand "org.eclipse.ui.externaltools.ExternalToolBuilder", LaunchConfigHandle: builder
      file {
         withXml {
            def projectNode = it.asNode()
            projectNode.iterator().each { subNode ->
               String subNodeText = "" + subNode
               if (subNodeText.startsWith("buildSpec")) {
                  subNode.iterator().each { buildCmd ->
                     String nameNode = buildCmd?.name
                     if (nameNode.contains("ExternalToolBuilder")) {
                        buildCmd.appendNode("triggers", "full,incremental,")
                     }
                  }
               }
            }
         }
      }
   }
}  

// Hide the various derived directories from Eclipse
project.eclipse.project.file.withXml { provider ->
   ignoreResourcesFromDirectories(provider, [ "build", 
                                              "gwt-unitCache", 
                                              "www-test", 
                                              "war/com.cedarsolutions.santa.SantaExchange.JUnit", 
                                              "war/santaexchange", 
                                              "war/WEB-INF/deploy", 
                                              "war/WEB-INF/lib", 
                                              "war/WEB-INF/appengine-generated", 
                                              "WEB-INF", 
                                              "extras", ])
}

// Customize the Eclipse .classpath file
eclipse.classpath.file {
   whenMerged { classpath ->

      // Change the default output directory to war/WEB-INF/classes instead of bin
      classpath.entries.findAll { entry -> entry.kind == "output" && entry.path == "bin" }.each { entry ->
         entry.path = "war/WEB-INF/classes"
      }

      // Test output should go to test-bin, so it can be separated for coverage purposes
      classpath.entries.findAll { entry -> entry.kind == "src" && entry.path == "test" }.each { entry ->
         entry.output = "test-bin"
      }

      // Replace the "gradle/src/suites source" folder with just "suites", and sent classes to test-bin
      classpath.entries.findAll { entry -> entry.kind == "src" && entry.path == "gradle/src/suites" }.each { entry ->
         entry.path = "suites"
         entry.output = "test-bin"
      }

      // Add the devmode runtime dependencies to the Eclipse classpath
      // Note: the ".nondependnecy" attributes means that this shouldn't go into the war
      withXml { xml ->
         def node = xml.asNode()
         configurations.devmodeRuntime.each { devmode ->
            node.appendNode("classpathentry", [ kind : "lib", path : devmode.canonicalPath, exported : "true", ])
                .appendNode("attributes").appendNode("attribute",  [ name : "org.eclipse.jst.component.nondependency", value : "", ])
         }
      }

      // Exclude the provided dependencies (like GWT) from the war file so Eclipse is consistent with gradle build
      // Note: the ".nondependnecy" attributes means that this shouldn't go into the war
      withXml { xml ->
         def node = xml.asNode()
         configurations.providedRuntime.each { provided ->
            def path = provided.canonicalPath.replace("\\", "/")
            node."classpathentry".findAll { it.@kind == "lib" && it.@path == path }.each { entry ->
               entry.appendNode("attributes").appendNode("attribute",  [ name : "org.eclipse.jst.component.nondependency", value : "", ])
            }
         }
      } 

      // Reorder the source packages the way I want them to appear
      def order = [ "resources", "src", "test", "suites", ]
      def all = classpath.entries.findAll { entry -> entry.kind == "src" }
      classpath.entries.removeAll(all)
      order.eachWithIndex() { path, index -> 
         all.findAll { entry -> entry.kind == "src" && entry.path == path }.each { entry -> 
            classpath.entries.add(index, entry) 
         } 
      }

      // Put all of the "con" classpath entries (like the JRE container) at the bottom
      all = classpath.entries.findAll { entry -> entry.kind == "con" }
      classpath.entries.removeAll(all)
      withXml { xml ->
         def node = xml.asNode()
         all.findAll { entry ->
            node.appendNode("classpathentry", [ kind : "con", path : entry.path, exported : entry.exported, ])
         }
      }

   }
}

// Ignore resources in a specific directory
// See: http://forums.gradle.org/gradle/topics/eclipse_generated_files_should_be_put_in_the_same_place_as_the_gradle_generated_files
def ignoreResourcesFromDirectories(provider, directories) {
   sleep 20 // so the timestamp is always different
   def filter = provider.asNode().appendNode("filteredResources").appendNode("filter")
   filter.appendNode("id", String.valueOf(System.currentTimeMillis()))  // this id must be unique
   filter.appendNode("name")
   filter.appendNode("type", "26")
   def matcher = filter.appendNode("matcher")
   matcher.appendNode("id", "org.eclipse.ui.ide.orFilterMatcher")
   def arguments = matcher.appendNode("arguments")
   directories.each {
      def dirMatcher = arguments.appendNode("matcher")
      dirMatcher.appendNode("id", "org.eclipse.ui.ide.multiFilter")
      dirMatcher.appendNode("arguments", "1.0-projectRelativePath-matches-true-false-${it}")
   }
}


// ***************
// * Gradle hooks
// ***************
// This code hooks into Gradle to modify behavior at build

// Test summary listener that prints out test results when tests are executed
// This makes the output legible in Eclipse; normally, the output isn't printed because Eclipse as a dumb terminal
// See: http://forums.gradle.org/gradle/topics/how_to_print_a_maven_like_test_summary_on_the_console
class TestSummary implements org.gradle.api.tasks.testing.TestListener {
    long passed;
    long failed;
    long skipped;

    public void beforeSuite(org.gradle.api.tasks.testing.TestDescriptor suite) {
        passed = 0;
        failed = 0;
        skipped = 0;
    }

    public void afterSuite(org.gradle.api.tasks.testing.TestDescriptor suite, org.gradle.api.tasks.testing.TestResult result) {
        System.out.printf("*** Test results: passed=%d, failed=%d, skipped=%d\n", passed, failed, skipped);
    }

    public void beforeTest(org.gradle.api.tasks.testing.TestDescriptor test) {
    }

    public void afterTest(org.gradle.api.tasks.testing.TestDescriptor test, org.gradle.api.tasks.testing.TestResult result) {
        passed += result.getSuccessfulTestCount();
        failed += result.getFailedTestCount();
        skipped += result.getSkippedTestCount();
    }
}

// Add a test sumamry listener to print test output
gradle.addListener(new TestSummary())
